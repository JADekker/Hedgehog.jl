adr_id: 002
title: "Pricer Callable Struct"
status: Accepted
date: 2025-03-11
context: |
  In ADR-001, we decided that pricing should be structured around three components:
    - A `payoff` that subtypes `AbstractPayoff` (e.g., `VanillaEuropeanCall`)
    - Market data (`marketInputs`) that subtypes `AbstractMarketInputs` (e.g., `BlackScholesInputs`)
    - A `pricingMethod` that subtypes `AbstractPricingMethod` (e.g., `BlackScholesMethod`)

  We now need a way to **use these three components to compute a price** in a structured and reusable manner.  
  The approach should be clear, extensible, and allow different pricing methodologies while maintaining a simple API for users.

decision: |
  - Introduce a `Pricer{P, M, S}` struct that holds:
      - A `payoff::P <: AbstractPayoff`
      - Market data `marketInputs::M <: AbstractMarketInputs`
      - A `pricingMethod::S <: AbstractPricingMethod`
  - Define `Pricer` as a **callable struct**, meaning `pricer()` will return the computed price.
  - Use **multiple dispatch** to determine the pricing computation based on the combination of `(payoff, marketInputs, pricingMethod)`.
  - Ensure `pricer()` only computes **price**; sensitivity calculations (e.g., Greeks) will have dedicated mechanisms.

consequences:
  positive:
    - "Encapsulates all pricing logic in a single object, reducing the need for multiple function arguments."
    - "Improves usability: Users can price an option naturally with `pricer()`."
    - "Leverages multiple dispatch to ensure that the correct pricing method is used."
  negative:
    - "Callable structs may be unexpected for users who assume `Pricer` is only a data container."
    - "Might require additional callable wrappers for sensitivities (e.g., `DeltaCalculator`)."

alternatives:
  - name: "Use an explicit `price(pricer)` function instead"
    pros: "More explicit API, avoids unexpected callable behavior."
    cons: "Less ergonomic, requiring an extra function call."

  - name: "Make the pricing method (`pricingMethod`) callable instead"
    pros: "Gives users more fine-grained control over the pricing process."
    cons: "Users would have to manually call the pricing method with the right inputs."

references:
  - adr-001-structuring-pricing.yaml
