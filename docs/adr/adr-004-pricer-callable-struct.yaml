adr_id: 004
title: "Pricing Method Dispatch via Pricer{A, B, C}"
status: Accepted
date: 2025-03-11
context: |
  The Hedgehog2.jl pricing framework must support modular pricing techniques that integrate with multiple payoffs, market data configurations, and pricing methodologies.
  To ensure flexibility and extensibility, pricing calculations must be structured using Julia’s multiple dispatch based on the combination of a `payoff`, `marketInputs`, and `pricingMethod`, using a `compute_price` function.

decision: |
  - Every new pricing method must be implemented by defining a new multiple dispatch method of `compute_price(payoff, market_inputs, method)`. The callable pricer() just runs compute_price on its three fields.
  - `Pricer` should not contain a universal pricing function—each `(payoff, marketInputs, pricingMethod)` combination must define its own dispatch specialization.
  - The pricing logic should **never** be embedded inside `pricingMethod` or `payoff` structs.
  - Example implementation:
      ```julia
      function compute_price(payoff::VanillaEuropeanCall, market_inputs::BlackScholesInputs, pricing_method::BlackScholesMethod})()
          S, K, r, σ, T = market_inputs.spot, payoff.strike, market_inputs.rate, market_inputs.sigma, payoff.time
          d1 = (log(S / K) + (r + 0.5 * σ^2) * T) / (σ * sqrt(T))
          d2 = d1 - σ * sqrt(T)
          return S * cdf(Normal(), d1) - K * exp(-r * T) * cdf(Normal(), d2)
      end
      ```

consequences:
  positive:
    - "Ensures modularity: Each pricing method can be added separately using Julia’s multiple dispatch with a new compute_price method."
    - "Explicitly defines how new pricing methods must be structured."
    - "Avoids incorrect designs where pricing logic is inside structs."
  negative:
    - "Requires defining a `compute_price` method explicitly for each combination of payoff, market inputs, and pricing method."
    - "Less flexible than embedding pricing in the struct, but ensures modularity."

alternatives:
  - name: "Store pricing logic inside the `AbstractPricingMethod` subtype"
    pros: "Simplifies structure since each pricing method contains its logic."
    cons: "Breaks modularity—pricing logic would be tied to the struct rather than using multiple dispatch."

references:
  - adr-001-payoff.yaml
  - adr-002-market-inputs.yaml
  - adr-003-pricing-methods.yaml